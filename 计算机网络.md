<!-- GFM-TOC -->
* [OSI7 层协议](#osi7-层协议)
* [运输层协议概述](#运输层协议概述)
* [UDP 报头格式](#udp-报头格式)
* [TCP 报头格式](#tcp-报头格式)
* [TCP 三次握手](#tcp-三次握手)
* [TCP 四次挥手](#tcp-四次挥手)
* [TCP 长连接与短连接](#tcp-长连接与短连接)
* [CLOSE_WAIT 很多](#closewait-很多)
* [DNS 解析过程](#dns-解析过程)
* [ARP 地址解析协议](#arp-地址解析协议)
* [交换机和路由器的区别](#交换机和路由器的区别)
* [TCP 如何保证数据的可靠传输的](#tcp-如何保证数据的可靠传输的)
* [TCP 拥塞控制](#tcp-拥塞控制)
<!-- GFM-TOC -->

## OSI7 层协议
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)

https://www.cnblogs.com/kangfeng/p/8422235.html（主要看图的对比）
http://blog.sina.com.cn/s/blog_60e96a410100my15.html（最后一段）

分层协议好处：
* 各层之间是独立的。某一层并不需要知道他的下一层是如何实现，仅需要知道该层的接口所提供的服务。
* 灵活性好。当任何一层发生变化时（如技术的变化），只要曾间接口关系不变，则在这层以上或以下各层均不受影响。
* 结构上可分割。各层都可以采用最合适的技术来实现。
* 易于实现和维护。因为整个系统已被分解为若干个相对独立的子系统。
* 能促进标准化工作，因为每一层的功能及其所提供的服务都已有了精确的说明。

## 运输层协议概述
* 通信的真正端点并不是主机而是主机中的进程，运输层提供应用进程间的逻辑通信。运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。运输层有两种不同的运输协议，即面向连接的TCP和无连接的UDP。
* TCP/IP的运输层用一个16位的端口号标志一个端口，标志计算机应用层中的各个进程和运输层交互时的层间接口。常用的服务端端口号：
    * FTP : 21/20 (21控制，20数据)
    * SSH : 22
    * TELNET : 23
    * SMTP : 25
    * DNS : 53
    * HTTP : 80
    * POP3 : 110
    * HTTPS : 443
    * SOCKETS : 1080

### 用户数据报协议UDP特点
* UDP是无连接的。即发送数据之前不需要建立连接（发送数据结束也没有连接可释放），减少了开销以及发送数据之前的延迟。
* UDP尽最大努力交付。即不保证可靠交付，主机不需要维持复杂的连接状态表。
* UDP是面向报文的。发送方的UDP对应用程序交下来的报文，添加首部后就交付给了IP层，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收方的UDP，对IP层交上来的报文，去除首部后就交给上层的应用进程。
* UDP没有拥塞控制。
* 支持一对一、一对多、多对一、多对多交互通信。
* UDP首部开销小。

### 传输控制协议TCP特点
* TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接，传送完数据后，必须释放TCP连接。
* TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。
* TCP面型字节流。“流”指的是流入到进程或从进程流出的字节序列。TCP把应用程序交下来的数据看成是一连串无结构的字节流。TCP和UDP在发送报文时所采用的方式完全不同。TCP对应用进程一次把多长的报文发送到TCP的缓存中是不关心的。TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送报文长度是进程给出的）。如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些在传送。如果应用进程一次只发来一个字节，TCP也可以等待积累有足够多的字节后在构成报文段发送出去。
* TCP提供全双工通信。
* 每一条TCP连接只能有两个端点（套接字所确定）。

## UDP 报头格式
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)

各字段意义：
* 源端口：需要回信时选用。
* 目的端口：终点交付报文时必用。
* 长度：UDP用户数据报的长度，其最小值是8（仅有首部）。 
* 检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。

伪首部并不是UDP用户数据报真正的首部，只在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。
https://blog.csdn.net/stpeace/article/details/73699603

## TCP 报头格式
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)

各字段意义：
* 源端口和目的端口：与UDP相似。
* 序号：首部中的序号指的是本报文段所发送的数据的第一个字节的序号。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按序编号。
* 确认号：期望收到对方下一个报文段的第一个数据字节的序号。
* 数据偏移：实际指的就是TCP报文段首部的长度。
* 保留：保留为今后使用。
* URG：表示本报文段中发送的数据是否包含紧急数据。后面的紧急指针字段只有当URG=1时才有效。URG=1，表示有紧急数据，不要按排队顺序来传送，会将紧急数据插入到报文段数据的最前面。
* 确认ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在建立连接后所有传送的的报文段都必须把ACK置1。
* PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为PSH=1，则表示对方应当立即把数据提交给上层，而不是缓存起来。
* RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。
* 同步SYN：在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方同意建立连接，应在响应报文中使SYN=1和ACK=1，表明这是连接接受报文。
* 终止FIN：用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放连接。
* 窗口：窗口指的是发送本报文端点的一方的接收窗口。例如，确认号是701，窗口字段是1000，这表明，从701号算起，发送此报文段的一方还有1000个字节数据的接收缓存空间。
* 检验和：
* 紧急指针：
* 选项：

## TCP 三次握手
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)

客户端的三个状态：
* CLOSED
* SYN-SENT
* ESTABLISHED

服务器的三个状态：
* CLOSED
* SYN-RCVD
* ESTABLISHED

SYN=1的报文段不能携带数据，但要消耗一个序号。
ACK=1的报文段可以不携带数据，则不需要消耗序号。

TCP是全双工的，在建立连接的时候，为什么要进行三次握手？
答：为了保证窗口机制。

## TCP 四次挥手
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)

客户端的四个状态：
* ESTABLISHED
* FIN-WAIT-1（终止等待）
* FIN-WAIT-2
* TIME-WAIT
* CLOSED

服务器的四个状态：
* ESTABLISHED
* CLOSE-WAIT（关闭等待）
* LASK-ACK（最后确认）
* CLOSED

FIN=1的报文段即使不携带数据，也要消耗一个序号。

MSL：最长报文段寿命。

## TCP 长连接与短连接
[参考1](https://www.cnblogs.com/pangguoping/p/5571422.html)
[参考2](https://blog.csdn.net/pmt123456/article/details/58233999)

## CLOSE_WAIT 很多
服务器可能会产生 504 Bad Gateway timeout 网关超时错误。

原因：服务端由于某种原因导致socket连接没有释放关闭连接,致使监听port打开的句柄数到了1024个，且均处于close_wait的状态，最终造成配置的port被占满出现“Too many open files”，无法再进行通信。 

解决办法：

* setSoTimeout()方法设置超时。
* 调整系统参数，包括句柄相关参数和TCP/IP的参数。


## DNS 解析过程

### 相关概念概述
* 域名系统DNS被设计为一个联机分布式数据库系统，用来把主机名字转换为IP地址。
* 域名到IP地址的解析是由分布式在因特网上的许多域名服务器程序共同完成的，运行域名服务器程序的机器称为域名服务器。
* 域名到IP地址的解析过程主要是，发送DNS请求报文，以UDP（数据报）/TCP（报文段）的方式发送给域名服务器，服务器查找到域名后，把IP放在回答报文中，应用进程获得目的主机IP后即可进行通信。

### 域名结构
任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。

域名具有层次结构，从上到下依次为：根域名、顶级域名、第二级域名。

<div align="center"> <img src="./imgs/network/dns.jpg"/> </div><br>

### 域名服务器
一个服务器所管辖的范围叫做“区”，每一个区设置相应的权限域名服务器，用来保存该区中所有主机的域名到IP地址的映射。DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位。

根据域名服务器所起的作用，可以把域名服务器划分为四中不同的类型：

* 根域名服务器，知道顶级域名服务器的IP地址。
* 顶级域名服务器，知道所管理的二级域名的IP地址。
* 权限域名服务器，负责管理区的域名。
* 本地域名服务器，如大学，都拥有。

### 解析过程
主机向本地域名服务器的查询一般都是采用<b>递归查询</b>。如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让主机自己进行下一步的查询。

本地域名服务器向根域名服务器的查询通常是采用<b>迭代查询</b>。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器进行查询。

可以选择使用哪种查询方式。

[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F)

## ARP 地址解析协议

### 相关概念
IP地址就是给因特网上的每一个主机的每一个接口分配一个在全世界范围是唯一的32位的表示符。

ARP解决的是同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题，如果接收方是不同局域网上的主机，那么发送方通过ARP得到的是同一个局域网的某个路由器的硬件地址。

[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp)

## 交换机和路由器的区别
* 工作所在的OSI层次不一样。交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； 路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。
* 数据转发所依据的对象也不一样。交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。
* 是否可以分割广播域。由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； 连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。

## TCP 如何保证数据的可靠传输的
可以使用一些可靠的传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。下面假设A发送B接收。

* 建立连接（标志位）：通信前确认通信实体存在。
* 序号机制（序号、确认号）：确保了数据是按序、完整到达。
* 数据校验（校验和）：CRC校验全部数据。
* 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
* 窗口机制（窗口）：提供流量控制，避免过量发送。
* 拥塞控制：同上。

### 停止等待协议
停止等待协议的信道利用率很低。

<div align="center"> <img src="./imgs/network/停止等待1.jpg"/> </div><br>

* 无差错情况：A发送后暂停，等待B确认，收到B确认后再发送。
* 出现差错：B检测出内容出错或A发送丢失，那么根据超时重传机制，A通过设置超时计时器时间确定是否重发，若在时间内到达则取消超时计时器。

<div align="center"> <img src="./imgs/network/停止等待2.jpg"/> </div><br>

* 确认丢失：如果B的确认丢失，那么A超时计时器到期后就要重传M1，假定B又收到了M1，那么应采取两个行动：
    * 丢弃这个M1。
    * 对A重新发送确认。
* 确认迟到：如果B的确认迟到了，那么A收到迟到的确认后应丢弃；而B对重传的M1应丢弃，并重新发送确认。

### 滑动窗口
前提：
<div align="center"> <img src="./imgs/network/窗口1.jpg"/> </div><br>

* 发送方A接收到了接收方B发来的确认报文段，其中包括确认号和窗口。根据这两个数据A就构造出自己的窗口。
* 在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传时使用。

发送方A：
<div align="center"> <img src="./imgs/network/窗口2.jpg"/> </div><br>
<div align="center"> <img src="./imgs/network/窗口3.jpg"/> </div><br>
<div align="center"> <img src="./imgs/network/窗口6.jpg"/> </div><br>

* A发送了一定序号数据并未接收到B的确认报文段，那么该段数据在窗口中标识为已发送但未收到确认。
* A收到B的确认报文段后根据窗口（不变）即确认号，选择向前滑动窗口或窗口不动。
* A发送完所有数据后序号已用完，但还没有收到确认，停止发送。

接收方B：
<div align="center"> <img src="./imgs/network/窗口4.jpg"/> </div><br>
<div align="center"> <img src="./imgs/network/窗口5.jpg"/> </div><br>

* 当B收到的报文段中的序号没有按序的情况，B会保留该序号，返回给A的报文段中的确认序号仍为之前的确认序号。
* 当B收到的报文段中包括了之前缺少的报文段序号后，B会将新的确认号以及窗口发送给A。

### 超时重传时间的选择

[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93)

修正：报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为2倍的旧的重传时间。

## TCP 拥塞控制
计算机网路中的链路容量（带宽）、交换节点中的缓存和处理机等，都是网络资源。

拥塞：某段时间，网络中的某一资源的需求超过了该资所能提供的可用部分。

拥塞控制：防止过多的数据注入到网路中，这样可以使网络中的路由器或链路不致过载。

[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)