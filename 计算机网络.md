<!-- GFM-TOC -->
* [OSI7 层协议](#osi7-层协议)
* [运输层协议概述](#运输层协议概述)
* [UDP 报头格式](#udp-报头格式)
* [TCP 报头格式](#tcp-报头格式)
* [TCP 三次握手](#tcp-三次握手)
* [TCP 四次挥手](#tcp-四次挥手)
* [DNS 解析过程](#dns-解析过程)
* [ARP 地址解析协议](#arp-地址解析协议)
* [交换机和路由器的区别](#交换机和路由器的区别)
<!-- GFM-TOC -->

## OSI7 层协议
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)

https://www.cnblogs.com/kangfeng/p/8422235.html（主要看图的对比）
http://blog.sina.com.cn/s/blog_60e96a410100my15.html（最后一段）

分层协议好处：
* 各层之间是独立的。某一层并不需要知道他的下一层是如何实现，仅需要知道该层的接口所提供的服务。
* 灵活性好。当任何一层发生变化时（如技术的变化），只要曾间接口关系不变，则在这层以上或以下各层均不受影响。
* 结构上可分割。各层都可以采用最合适的技术来实现。
* 易于实现和维护。因为整个系统已被分解为若干个相对独立的子系统。
* 能促进标准化工作，因为每一层的功能及其所提供的服务都已有了精确的说明。

## 运输层协议概述
* 通信的真正端点并不是主机而是主机中的进程，运输层提供应用进程间的逻辑通信。运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。运输层有两种不同的运输协议，即面向连接的TCP和无连接的UDP。
* TCP/IP的运输层用一个16位的端口号标志一个端口，标志计算机应用层中的各个进程和运输层交互时的层间接口。常用的服务端端口号：
    * FTP : 21
    * SSH : 22
    * TELNET : 23
    * SMTP : 25
    * DNS : 53
    * HTTP : 80
    * POP3 : 110
    * HTTPS : 443
    * SOCKETS : 1080

### 用户数据报协议UDP特点
* UDP是无连接的。即发送数据之前不需要建立连接（发送数据结束也没有连接可释放），减少了开销以及发送数据之前的延迟。
* UDP尽最大努力交付。即不保证可靠交付，主机不需要维持复杂的连接状态表。
* UDP是面向报文的。发送方的UDP对应用程序交下来的报文，添加首部后就交付给了IP层，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收方的UDP，对IP层交上来的报文，去除首部后就交给上层的应用进程。
* UDP没有拥塞控制。
* 支持一对一、一对多、多对一、多对多交互通信。
* UDP首部开销小。

### 传输控制协议TCP特点
* TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接，传送完数据后，必须释放TCP连接。
* TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。
* TCP面型字节流。“流”指的是流入到进程或从进程流出的字节序列。TCP把应用程序交下来的数据看成是一连串无结构的字节流。TCP和UDP在发送报文时所采用的方式完全不同。TCP对应用进程一次把多长的报文发送到TCP的缓存中是不关心的。TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送报文长度是进程给出的）。如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些在传送。如果应用进程一次只发来一个字节，TCP也可以等待积累有足够多的字节后在构成报文段发送出去。
* TCP提供全双工通信。
* 每一条TCP连接只能有两个端点（套接字所确定）。

## UDP 报头格式
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)

各字段意义：
* 源端口：需要回信时选用。
* 目的端口：终点交付报文时必用。
* 长度：UDP用户数据报的长度，其最小值是8（仅有首部）。 
* 检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。

伪首部并不是UDP用户数据报真正的首部，只在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。
https://blog.csdn.net/stpeace/article/details/73699603

## TCP 报头格式
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)

各字段意义：
* 源端口和目的端口：与UDP相似。
* 序号：首部中的序号指的是本报文段所发送的数据的第一个字节的序号。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按序编号。
* 确认号：期望收到对方下一个报文段的第一个数据字节的序号。
* 数据偏移：实际指的就是TCP报文段首部的长度。
* 保留：保留为今后使用。
* URG：表示本报文段中发送的数据是否包含紧急数据。后面的紧急指针字段只有当URG=1时才有效。URG=1，表示有紧急数据，不要按排队顺序来传送，会将紧急数据插入到报文段数据的最前面。
* 确认ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在建立连接后所有传送的的报文段都必须把ACK置1。
* PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为PSH=1，则表示对方应当立即把数据提交给上层，而不是缓存起来。
* RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。
* 同步SYN：在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方同意建立连接，应在响应报文中使SYN=1和ACK=1，表明这是连接接受报文。
* 终止FIN：用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放连接。
* 窗口：窗口指的是发送本报文端点的一方的接收窗口。例如，确认号是701，窗口字段是1000，这表明，从701号算起，发送此报文段的一方还有1000个字节数据的接收缓存空间。
* 检验和：
* 紧急指针：
* 选项：

## TCP 三次握手
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)

客户端的三个状态：CLOSED,SYN-SENT,ESTABLISHED.
服务器的三个状态：CLOSED,SYN-RCVD,ESTABLISHED.

SYN=1的报文段不能携带数据，但要消耗一个序号。
ACK=1的报文段可以不携带数据，则不需要消耗序号。

## TCP 四次挥手
[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)

客户端的四个状态：ESTABLISHED,FIN-WAIT-1（终止等待）,FIN-WAIT-2,TIME-WAIT,CLOSED.
服务器的四个状态：ESTABLISHED,CLOSE-WAIT（关闭等待）,LASK-ACK（最后确认）,CLOSED.

FIN=1的报文段即使不携带数据，也要消耗一个序号。

MSL：最长报文段寿命。

## DNS 解析过程

### 相关概念概述
* 域名系统DNS被设计为一个联机分布式数据库系统，用来把主机名字转换为IP地址。
* 域名到IP地址的解析是由分布式在因特网上的许多域名服务器程序共同完成的，运行域名服务器程序的机器称为域名服务器。
* 域名到IP地址的解析过程主要是，发送DNS请求报文，以UDP（数据报）/TCP（报文段）的方式发送给域名服务器，服务器查找到域名后，把IP放在回答报文中，应用进程获得目的主机IP后即可进行通信。

### 域名结构
任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。

域名具有层次结构，从上到下依次为：根域名、顶级域名、第二级域名。

<div align="center"> <img src="./imgs/dns.jpg"/> </div><br>

### 域名服务器
一个服务器所管辖的范围叫做“区”，每一个区设置相应的权限域名服务器，用来保存该区中所有主机的域名到IP地址的映射。DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位。

根据域名服务器所起的作用，可以把域名服务器划分为四中不同的类型：

* 根域名服务器，知道顶级域名服务器的IP地址。
* 顶级域名服务器，知道所管理的二级域名的IP地址。
* 权限域名服务器，负责管理区的域名。
* 本地域名服务器，如大学，都拥有。

### 解析过程
主机向本地域名服务器的查询一般都是采用<b>递归查询</b>。如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让主机自己进行下一步的查询。

本地域名服务器向根域名服务器的查询通常是采用<b>迭代查询</b>。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器进行查询。

可以选择使用哪种查询方式。

[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F)

## ARP 地址解析协议

### 相关概念
IP地址就是给因特网上的每一个主机的每一个接口分配一个在全世界范围是唯一的32位的表示符。

ARP解决的是同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题，如果接收方是不同局域网上的主机，那么发送方通过ARP得到的是同一个局域网的某个路由器的硬件地址。

[完整内容参考](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp)

## 交换机和路由器的区别
* 工作所在的OSI层次不一样。交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； 路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。
* 数据转发所依据的对象也不一样。交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。
* 是否可以分割广播域。由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； 连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。