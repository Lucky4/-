* [topk 问题](#topk-问题)
* [设计缓存](#设计缓存)

## topk 问题

* 如果内存足够大，可以将数据排序，选取topk。
* 如果内存不够大，通常比较好的方式是分治 + Trie树/hash + 小顶堆，即先将数据集按照hash方法分解成多个小数据集，然后使用Trie树或者hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的K个数，最后在所有topK中求出最终的topK。

ps：小顶堆的处理方式是先建立1000个数的小顶堆，建堆的时间复杂度为O(klogk)，然后遍历后续的数字，并与堆顶数字进行比较，若比最小的数小，则继续读取后续数字；若比堆顶数字大，则替换堆顶元素并重新调整堆为小顶堆。整个过程直至1亿个数全部遍历完为止。然后按中序遍历的方式输出当前堆的所有1000个数字，时间复杂度为O(nklogk)。


## 设计缓存

哈希+双向链表

[参考](https://leetcode.com/problems/lru-cache/description/)
[参考](http://flychao88.iteye.com/blog/1977653)